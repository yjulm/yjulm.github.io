{"posts":[{"title":"显示器与触摸屏的一对一绑定原理和解析","content":" 在平常的系统使用场景中几乎很少会使用触摸屏，来尝试解决这个问题的人也从来没有，则我成了这第一个吃螃蟹的人。问题起因是遇到了这样一个特殊的场景，在大量的工控主板中设计中，工控厂商一般会在 BIOS 中开启一个 LVDS 监视器端口。但是在主板硬件中处并没有引出该硬件接口，此时在同时接入 HDMI 和 VGA 两块显示器的时候，在系统中却显示的有三个屏幕。 这原本看起来本没什么问题，当我们接入 HDMI 显示器是带有触摸的，并在系统设置中将其设置为主显示器时，问题就会出现在开机的时候。在主机先执行开机的情况下，这些显示器并没有接入电源时，待系统差不多完成开机这个时候给屏幕接入电源，则系统会随机出现 HDMI 与 VGA 的显示颠倒，同时 HDMI 自带的触摸屏幕也随机出现颠倒，将我们的触摸操作执行在了 VGA 的显示器中。这在一个不使用鼠标作为操作交互的产品中，问题就显得非常严重了。当触摸操作响应在 VGA 显示器中时，而你却是在 HDMI 上操作。不使用鼠标的情况下，这种状态是完全无法正常使用操作系统的。那么如何在不重启系统的情况下矫正触摸，则成了棘手的问题。 一、 系统自带的矫正工具 这个问题微软或许自己就知道，提前准备了这样一个矫正功能，但要调用这个功能却层层复杂。它处在 控制面板 --&gt; 平板电脑设置 --&gt; 设置 这样一个操作流程中。这在一个没有鼠标且又触摸颠倒的系统状况下，这成了几乎不可能达成的操作，最重要的是大多数人并不知道有这么一个矫正工具。 图 1-1 触摸矫正工具 那如何用代码实现一个能开机自启动并自定矫正的工具，这问题的关键就成了怎样编程才能矫正触摸。但即便是翻遍了 MSDN 上所有有关触摸屏幕的文档后，你依旧不能找到任何线索。眼角默默流出忧伤泪水的你，必须接受微软没有开放这一接口的设定！ 微软没有开放触摸相关的接口，那么微软自己的工具为啥能矫正，这就是突破口！通过打开这个矫正工具并借助任务管理器的显示命令行功能，我们可以知道该工具的路径和调用参数如下： 图 1-2 任务管理器的可用信息 通过简单使用该工具可知道它的工作逻辑是，将所有屏幕上显示白屏窗口。让用户使用 Enter 键来移动提示语到需要设置的屏幕中，再让用户触碰触屏。通过这两个操作来同时确定用户选择的显示器和触摸屏，然后系统底层将这两者信息绑定在一起并应用该设置。 光知道工作逻辑并没实际用途，还需要知道矫正操作的详细细节。该系统程序为 C++ 语言开发，此时则需要借助静态分析工具 IDA Pro 来帮助我们了解详细过程。经过 IDA Pro 的简单反汇编，并通过任务管理器中提取的启动参数 -touch 我们可以快速在主函数中定位到以下细节： 图 1-3 主函数 由图可知代码将在 115 行位置开始进入映射流程。该程序同时承担了触摸屏和电磁笔的矫正功能，则通过启动参数 -touch 和 -pen 来分辨设定并标记到 v13 ，在启动映射流程时将其传递给 StartMapping 。 图 1-4 StartMapping 的准备工作 在 StartMapping 中的 20-21 行位置处，通过观察其名称与其内部调用的系统API函数 EnumDisplayMonitors ，EnumDisplayDevicesW ， GetPointerDevices 可大致推断，这两个函数的本质是取出 监视器 和 触点设备（Touch 与 Pen） 的基础信息。目的是为了后面的 窗口事件循环 处理函数 MDMWndProc 做准备，正如程序的使用逻辑那样，让用户选择屏幕和触碰屏来达到确认设备的目的，这都是前期准备工作。下面的流程将进入 MDMWndProc 。 图 1-5 窗口消息循环 在 MDMWndProc 中检测触点抬起消息 WM_POINTERUP，并在此 PointerProc 中使用API GetPointerInfo 取得触摸的信息。使用内置消息 WM_APP + 2 触发 WriteDigitizerMonitorAssociations 写入触摸和屏幕的映射数据，待写入映射后再配合 BroadcastSettingChange 通知系统发生了映射变更。自此关键操作就完成了。这两个函数是实现校准的重点。下面将流程转入 WriteDigitizerMonitorAssociations 函数中。 图 1-6 写入映射信息 在 84 行位置使用了 RegDeleteKeyValueW 来删除了一个注册表值，我们依据此路径可在注册表中找到一个如下的键值对： 图 1-7 映射信息 从图 1-7 中我们可知道该 Key 正如图 1-6 中 78 行那样，将触摸设备的硬件路径格式化为一个带有20- 前缀的字符，并使用监视器硬件路径作为 Value ，以此构建一个映射键值对。现在将视线返回到图 1-6 中。在移除键值后的 88 行处跳转到 92 行继续往下执行，在对删除操作做错误检测后使用 AssociationAdd 将新的键值写会到注册表，该函数其主要行为就是构建前面的 Key 与 Value 并将其写入到删除的注册表位置，具体细节就不在此处详细展开。 这里需要说明的是，在 AssociationAdd 写入新的设备键值对以后的 96 行的 SetDisplayMapping 是 Win8/Win10特有的操作，在Win7系统是不存在这个这个操作的。该函数将在后面第二节详细说明。 1、 写入注册表的注意事项 对键值的写入操作有一个重要信息，该键值的路径已经显示了其属于系统层，对其读写操作有权限要求。解决办法有如下方式： 使用管理员权限运行程序，由此通过权限检查，但需要用户手动确认UAC弹窗。 使用一个 LocalSystem 权限组的服务程序代为执行该操作，也可通过权限检查。其原因是 MACHINE\\SOFTWARE\\Microsoft\\Wisp 路径对 &quot;NT AUTHORITY\\SYSTEM&quot; 开放 FullControl，而 LocalSystem 组的服务程序则默认拥有 &quot;NT AUTHORITY\\SYSTEM&quot; 账户权。有关此具体信息可参阅微软官方文档“开发需要管理员权限的应用程序”了解其开发细节。 在没有执行过矫正的系统注册表路径下 HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Wisp\\Pen 是不存在子键 Digimon 的，这需要自己手动新建。 在64位系统中且程序是32位时，Windows的 路径重定向 会导致导致修改成功却没有任何变化。大多数人可能会首先想到使用 Wow64DisableWow64FsRedirection 来禁用重定向功能，但非常遗憾的是该函数仅对文件系统路径有效。因此在新建 RegCreateKeyEx 或者 RegOpenKeyEx 打开该子项时，需要使用 KEY_WOW64_64KEY 权限来操作。有关详细信息请参阅文档 Registry Redirector 与 Registry Key Security and Access Rights 了解更多信息。针对以上的问题我们可以写出如下的辅助函数： typedef BOOL (WINAPI *IsWow64FuncPtr) ( _In_ HANDLE hProcess, _Out_ PBOOL Wow64Process ); bool IsWow64() { int ret{}; const auto proc = reinterpret_cast&lt;IsWow64FuncPtr&gt;( GetProcAddress(GetModuleHandle(TEXT(&quot;kernel32&quot;)), &quot;IsWow64Process&quot;)); return proc &amp;&amp; proc(GetCurrentProcess(), &amp;ret) &amp;&amp; ret; } /* * RegOpenKeyEx 在打开注册表键失败时（没有访问权），如果是管理员（管理员组内账户）， * 则可以启用 SE_TAKE_OWNERSHIP_NAME特权，并使用 WRITE_OWNER 权限打开 * document : https://docs.microsoft.com/zh-cn/windows/win32/sysinfo/registry-key-security-and-access-rights */ HKEY OpenRegKey(HKEY hKey, const wchar_t *subKey, bool owner, bool createNew, bool &amp;isCreate) { HKEY retKey{}; if (hKey) { DWORD code{}; REGSAM sam = KEY_READ | KEY_WRITE | (IsWow64() ? KEY_WOW64_64KEY : 0) //指示系统当前操作在 64 位注册表中 | (owner ? WRITE_OWNER : 0); if ((code = RegOpenKeyEx(hKey, subKey, 0, sam, &amp;retKey)) == ERROR_SUCCESS) isCreate = false; else { if (createNew) { if ((code = RegCreateKeyEx(hKey, subKey, 0, nullptr, REG_OPTION_NON_VOLATILE, sam, nullptr, &amp;retKey, nullptr)) == ERROR_SUCCESS) { isCreate = true; return retKey; } } } } return retKey; } 再对此如下使用即可操作子项 Digimon 的键值： HKEY retKey{}; bool isCreate{}; if ((retKey = OpenRegKey(HKEY_LOCAL_MACHINE, L&quot;SOFTWARE\\\\Microsoft\\\\Wisp\\\\Pen&quot;, false, true, isCreate)) != nullptr) { HKEY digimonKey{}; if ((digimonKey = OpenRegKey(retKey, L&quot;Digimon&quot;, false, true, isCreate)) != nullptr) { //do something } } 二、 让系统立即生效的映射通知 需要说明的是本文逆向过程中的截图均为Win8系统的程序，在早期的Win7中有关映射通知的实现和Win8以及后续系统不同。 1、 Win7系统的映射通知 Win7的通知操作和后续系统的设计不同，该操作实现在图 1-5 的 32 行 BroadcastSettingChange 中。至此Win7系统触摸矫正工作就已经全部完成。 图 1-8 Win7系统的映射通知 为了便于理解其，此处使用的是64位系统中的程序文件进行反编译操作，其关键代码在 25 行处，我们可以简单翻译为如下实现： bool BroadcastMappingChange() { /* * SendMessageTimeout 仅适用于桌面程序，在服务程序中使用能调用成功但操作不会成功！ * https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-sendmessagetimeouta#requirements */ DWORD_PTR dwResult; wchar_t msg[]{L&quot;TabletPCDigitizerMappingChanged&quot;}; //该字符串来自于系统触屏校准程序MultiDigiMon.exe 的反编译得到 if (SendMessageTimeout(HWND_BROADCAST, WM_SETTINGCHANGE, NULL, LPARAM(msg), SMTO_ABORTIFHUNG, 200, &amp;dwResult)) return true; return GetLastError() == ERROR_SUCCESS; } 2、 Win8/Win10系统的特殊映射通知 Win8以后的系统通知是由图 1-6 中第 96 行的 SetDisplayMapping 实施的。现在我们回到图 1-6 并双击函数名称将跳转该函数的定义处： 图 1-9 函数定义 该函数接受两个参数且使用 __stdcall 调用约定，这里需要提到一点，IDA Pro 毕竟是静态反汇编操作，很多时候不要完全相信 IDA Pro 的输出代码。在 64 位程序中该函数被提示为使用 __fastcall 的调用约定，这就是为什么同时使用 32 和 64 位程序来分析的原因。 不幸的是该函数微软并没有公布任何文档，且该函数在导出时采用了序号导出并没有名字。通过 IDA Pro 的导入列表可以知道该函数来自 User32.dll 的第 2532 号导出位置。经过各种搜索引擎的帮助我们在看雪论坛找到了该函数的底层实现名称为 NtUserSetDisplayMapping，但也仅仅知道名字而已。目前依据已知信息我们可以写出如下 不完整 的函数原型： typedef LONG32(__stdcall *NtUserSetDisplayMapping) (*** param1, *** param2); void SetDisplayMapping(*** param1, *** param2) { LONG32 ret = 0; const auto proc = reinterpret_cast&lt;NtUserSetDisplayMapping&gt;( GetProcAddress(GetModuleHandle(TEXT(&quot;user32&quot;)), MAKEINTRESOURCEA(2532))); if (proc != nullptr) ret = proc(param1, param2); } 将视线挪回到图 1-6 中，现仍旧是继续探索这两个参数的含义与类型的过程。沿着参数 v16 这个字节数组一路向上层追踪，可弄清 v16 是怎么创建出来的。往上寻得 v16 就是图 1-4 中第 16 行的 g_context，整个逆向工程就卡在此处毫无进展。在一段时间毫无进展后放弃了对Win8以上的系统的校准支持，此时的逆向工作停在了2019年10月。 时间来到两年后的2021年11月，再次遇到触摸问题得以抽空继续看看。这次换个思路，在经过同时使用 32 位和 64 位，以及将两组程序分为加载调试符号和不加载调试这样4种的反编译处理后，尝试沿着参数一直往上层追踪。进过大量测试发现这两个值在不重启系统情况下每次调试都不变，当屏幕或者触摸屏幕硬件拔插后会发生变化时，或重启系统后也会变化。通过对这两参数内存周围数据的查看时，观察第一个参数的内存地址旁边有HID触摸设备名称，第二个参数的内存地址旁边有监视器设备路径，依据这一特征大胆猜测了这两个参数应该是关于设备信息的数据。 图 1-10 不变的参数值 依据设备信息这一线索，经大量调试对比后在以下函数找到了这个不会变化的值，而这数据刚好在 POINTER_INFO 结构类型的 g_lastPointerInfo 全局变量，分析该 POINTER_INFO 结构的第五元素位置，确认第一参数其实是触屏的设备句柄。 图 1-11 POINTER_INFO结构中的设备句柄 后面同样的思路猜测第二参数应该与第一参数类似，并成功确认第二参数是监视器的设备句柄，于是整个函数定义的完整实现已经清晰明白，依据 32 和 64 位程序的不同参数类型与返回类型特点，最后写出最终的函数原型如下： typedef WINUSERAPI LRESULT(WINAPI *NtUserSetDisplayMapping) (_In_ HANDLE touch, _In_ HMONITOR display); bool SetDisplayMapping(HANDLE touch, HMONITOR display) { LRESULT ret = 0; const auto proc = reinterpret_cast&lt;NtUserSetDisplayMapping&gt;( GetProcAddress(GetModuleHandle(TEXT(&quot;user32&quot;)), MAKEINTRESOURCEA(2532))); if (proc != nullptr) ret = proc(touch, display); return ret == 1; } 2.1、 取得设备句柄 SetDisplayMapping 函数接受两个设备句柄，则必须先要取得监视器和触摸的设备句柄。在此我们以设备路径做匹配条件，实现以下操作即可取得设备句柄： BOOL __stdcall MonitorEnumProc(HMONITOR monitor, HDC hdc, LPRECT rect, LPARAM param) { MONITORINFOEX info{}; info.cbSize = sizeof(MONITORINFOEX); if (GetMonitorInfoW(monitor, &amp;info)) { int i = 0; while (true) { DISPLAY_DEVICE dev{}; dev.cb = sizeof(DISPLAY_DEVICE); if (EnumDisplayDevices(info.szDevice, i++, &amp;dev, EDD_GET_DEVICE_INTERFACE_NAME)) { //do something //eg: compare process bool compareResult = true; if (compareResult) { ((void**)param)[1] = monitor; return FALSE; //stop enum, Yes, we found it! } } else break; } } return TRUE; //continue enum } HMONITOR Test::Test_GetDisplayDeviceHandle(wchar_t displayPath[MAX_PATH]) { void* param[2]; param[0] = displayPath; param[1] = nullptr; EnumDisplayMonitors(nullptr, nullptr, MonitorEnumProc, (LPARAM)&amp;param); return static_cast&lt;HMONITOR&gt;(param[1]); } HANDLE Test::Test_GetTouchDeviceHandle(wchar_t hidPath[MAX_PATH]) { UINT count; if (GetRawInputDeviceList(nullptr, &amp;count, sizeof(RAWINPUTDEVICELIST)) == 0) { PRAWINPUTDEVICELIST list = new RAWINPUTDEVICELIST[count]; if (GetRawInputDeviceList(list, &amp;count, sizeof(RAWINPUTDEVICELIST))) for (UINT i = 0; i &lt; count; i++) if (list[i].dwType == RIM_TYPEHID) { UINT length = MAX_PATH; wchar_t path[MAX_PATH]{}; if (GetRawInputDeviceInfo(list[i].hDevice, RIDI_DEVICENAME, path, &amp;length)) { //do something } length = sizeof(RID_DEVICE_INFO); RID_DEVICE_INFO info{}; info.cbSize = sizeof(RID_DEVICE_INFO); if (GetRawInputDeviceInfo(list[i].hDevice, RIDI_DEVICEINFO, &amp;info, &amp;length)) { //do something //eg: info.hid.dwProductId, info.hid.dwVendorId, info.hid.usUsagePage, info.hid.usUsage; } length = 0; if (GetRawInputDeviceInfo(list[i].hDevice, RIDI_PREPARSEDDATA, nullptr, &amp;length) == 0) { LPBYTE data = new BYTE[length]{}; if (GetRawInputDeviceInfo(list[i].hDevice, RIDI_PREPARSEDDATA, data, &amp;length)) { PHIDP_PREPARSED_DATA preparsed = (PHIDP_PREPARSED_DATA)data; //do something } delete[] data; } return list[i].hDevice; //if the compare is success } } return nullptr; } 2.2、 取得设备路径 在上一小节中以设备路劲作为设备筛选的匹配条件，则如何取得设备路径就是关键操作。 2.2.1、 取得触摸设备的路径 在上方的 Test_GetTouchDeviceHandle 中使用 GetRawInputDeviceInfo 函数并搭配参数 RIDI_DEVICENAME、RIDI_DEVICEINFO、RIDI_PREPARSEDDATA 取得的多个信息，其实就能匹配并确认设备。获取触摸设备信息的另一个方式是采用通用 SetupApi 枚举设备来实现： bool Test::Test_GetTouchDevPath(wchar_t hid[MAX_PATH], int* len) { bool ret = false; GUID hidGuid{}; HidD_GetHidGuid(&amp;hidGuid); HDEVINFO infoSet; if ((infoSet = SetupDiGetClassDevs(&amp;hidGuid, nullptr, nullptr, DIGCF_DEVICEINTERFACE | DIGCF_PRESENT)) != INVALID_HANDLE_VALUE) { SP_DEVICE_INTERFACE_DATA interfaceData{}; interfaceData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA); for (int interfaceIndex = 0 ; SetupDiEnumDeviceInterfaces(infoSet, nullptr, &amp;hidGuid, interfaceIndex, &amp;interfaceData) ; ++interfaceIndex) { /* * https://docs.microsoft.com/zh-cn/windows/win32/api/setupapi/nf-setupapi-setupdigetdeviceinterfacedetaila */ DWORD detailReqSize{}; if (!SetupDiGetDeviceInterfaceDetail(infoSet, &amp;interfaceData, nullptr, 0, &amp;detailReqSize, nullptr) //第一次取缓冲区大小，一定返回FALSE &amp;&amp; GetLastError() == ERROR_INSUFFICIENT_BUFFER) { SP_DEVICE_INTERFACE_DETAIL_DATA* detailPtr = static_cast&lt;PSP_DEVICE_INTERFACE_DETAIL_DATA&gt;(calloc( detailReqSize, 1)); detailPtr-&gt;cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA); if (SetupDiGetDeviceInterfaceDetail(infoSet, &amp;interfaceData, detailPtr, detailReqSize, &amp;detailReqSize, nullptr)) { /* * https://docs.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-createfilea#communications-resources * https://docs.microsoft.com/en-us/windows/win32/devio/communications-resource-handles * 系统一般会在设备插入时就Open设备，并以独占模式CreateFile * 在此时访问权限使用 0 能够确保在访问被拒绝时在不访问设备的情况下查询一些元数据 * 同时还需要保证共享模式和系统已打开的模式不冲突 */ const HANDLE devPtr = CreateFile(detailPtr-&gt;DevicePath , 0, FILE_SHARE_READ | FILE_SHARE_WRITE, nullptr, OPEN_EXISTING, 0, nullptr); if (devPtr != INVALID_HANDLE_VALUE) { PHIDP_PREPARSED_DATA preparsedPtr{}; if (HidD_GetPreparsedData(devPtr, &amp;preparsedPtr)) //TODO: Only user-mode applications can call { HIDP_CAPS caps{}; if (HidP_GetCaps(preparsedPtr, &amp;caps) == HIDP_STATUS_SUCCESS) { //hidusage.h中没有，此处信息更具体:http://www.freebsddiary.org/APC/usb_hid_usages USAGE HID_USAGE_DIGITIZER_TOUCH_SCREEN = 0x04; if (caps.UsagePage == HID_USAGE_PAGE_DIGITIZER //数字化仪器,下属有触摸屏设备 &amp;&amp; caps.Usage == HID_USAGE_DIGITIZER_TOUCH_SCREEN) { //do something eg: compare process ret = wcscpy_s(hid, MAX_PATH, detailPtr-&gt;DevicePath) == 0; *len = wcslen(detailPtr-&gt;DevicePath); } } HidD_FreePreparsedData(preparsedPtr); } CloseHandle(devPtr); } } free(detailPtr); } if (ret) break; } SetupDiDestroyDeviceInfoList(infoSet); } return ret; } 2.2.2、 取得监视器设备路径 监视器的枚举操作除了上面的方法外，更广谱有效的方法是采用接口函数 DisplayConfigGetDeviceInfo 取得更加详细的信息，也有更多的可匹配参数可用： void Test::Test_GetDisplayDevPath(wchar_t hid[MAX_PATH], int* len) { UINT32 pathCount, modeCount; if (GetDisplayConfigBufferSizes(QDC_ALL_PATHS, &amp;pathCount, &amp;modeCount) == ERROR_SUCCESS) { DISPLAYCONFIG_PATH_INFO* pathPtr = new DISPLAYCONFIG_PATH_INFO[pathCount]{}; DISPLAYCONFIG_MODE_INFO* modePtr = new DISPLAYCONFIG_MODE_INFO[modeCount]{}; if (QueryDisplayConfig(QDC_ALL_PATHS, &amp;pathCount, pathPtr, &amp;modeCount, modePtr, nullptr) == ERROR_SUCCESS) { if (pathPtr &amp;&amp; pathCount) for (int i = 0; i &lt; pathCount; i++) { const DISPLAYCONFIG_PATH_INFO&amp; path = pathPtr[i]; { const LUID&amp; srcAdapterId = path.sourceInfo.adapterId; const LUID&amp; dstAdapterId = path.targetInfo.adapterId; const UINT&amp; srcId = path.sourceInfo.id; const UINT&amp; dstId = path.targetInfo.id; DISPLAYCONFIG_TARGET_DEVICE_NAME targetName{}; targetName.header.size = sizeof(DISPLAYCONFIG_TARGET_DEVICE_NAME); targetName.header.type = DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_NAME; targetName.header.adapterId = dstAdapterId; targetName.header.id = dstId; if (DisplayConfigGetDeviceInfo(&amp;targetName.header) == ERROR_SUCCESS) { bool hasPath = wcslen(targetName.monitorDevicePath); //有路径则说明设备在硬件层面上已连接 if (hasPath) { DISPLAYCONFIG_SOURCE_DEVICE_NAME deviceName{}; deviceName.header.size = sizeof(DISPLAYCONFIG_SOURCE_DEVICE_NAME); deviceName.header.type = DISPLAYCONFIG_DEVICE_INFO_GET_SOURCE_NAME; deviceName.header.adapterId = srcAdapterId; deviceName.header.id = srcId; if (DisplayConfigGetDeviceInfo(&amp;deviceName.header) == ERROR_SUCCESS) { //do something } DISPLAYCONFIG_ADAPTER_NAME adapterName{}; adapterName.header.size = sizeof(DISPLAYCONFIG_ADAPTER_NAME); adapterName.header.type = DISPLAYCONFIG_DEVICE_INFO_GET_ADAPTER_NAME; adapterName.header.adapterId = srcAdapterId; adapterName.header.id = srcId; if (DisplayConfigGetDeviceInfo(&amp;adapterName.header) == ERROR_SUCCESS) { //do something } adapterName.header.adapterId = dstAdapterId; adapterName.header.id = dstId; if (DisplayConfigGetDeviceInfo(&amp;adapterName.header) == ERROR_SUCCESS) { //do something } DISPLAYCONFIG_TARGET_PREFERRED_MODE preferredMode{}; preferredMode.header.size = sizeof(DISPLAYCONFIG_TARGET_PREFERRED_MODE); preferredMode.header.type = DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_PREFERRED_MODE; preferredMode.header.adapterId = dstAdapterId; preferredMode.header.id = dstId; if (DisplayConfigGetDeviceInfo(&amp;preferredMode.header) == ERROR_SUCCESS) { //do something } DEVMODE devMode{}; devMode.dmSize = sizeof(DEVMODE); if (EnumDisplaySettingsEx(deviceName.viewGdiDeviceName, ENUM_REGISTRY_SETTINGS, &amp;devMode, EDS_RAWMODE)) { //do something } } } } } delete[] pathPtr; delete[] modePtr; } } } 更多其他信息可阅读文章《自定义显示器的显示模式原理和实现》了解更多细节。 ","link":"https://yjulm.com/post/touch-screen-binding/"},{"title":"自定义显示器的显示模式原理和实现","content":" 在Windows系统的显示器设置中，微软为我们提供了如下的设置界面，来完成多屏幕的显示方案定制。比如设置多个屏幕的空间排列和显示方向、设置每个屏幕的分辨率大小、调整主显示屏幕、以及调整多个屏幕的协作能力是复制还是扩展。那么在此基础上，如何用代码自动化设置一个固定显示设置方案？下面将从基础API接口详细介绍显示器设置如何自定义。 图1 - 系统显示器设置 随着Windows历史发展，Windows发展出了两套不兼容的显示驱动模型。其分别是 Windows 2000/XP 以 NT5 为内核的XDDM驱动模型，以及后来的 Windows Vista/7/8/10 这些以 NT6 为内核的WDDM驱动模型。在此过程中屏幕相关的设置API也发展出了两代，其中 XDDM 模型的 API 接口主要以 DEVMODE 结构为主，WDDM模型的 API 接口主要以 DISPLAYCONFIG 为前缀的结构为主。 一、 XDDM 由于XDDM模型主要是为2000/XP等老式系统设计，在此我们不主要使用该模式的下接口。但该模式下的 API 接口有助于帮助我们理解Windows的显示模型。所以在此提出，该模型下主要提供以下几个主要接口函数： EnumDisplayDevices EnumDisplayMonitors EnumDisplaySettings EnumDisplaySettingsEx ChangeDisplaySettings ChangeDisplaySettingsEx GetMonitorInfo 在此我们主要使用 EnumDisplayDevices 接口函数，该函数的原型定义如下： BOOL EnumDisplayDevicesW( [in] LPCWSTR lpDevice, [in] DWORD iDevNum, [out] PDISPLAY_DEVICEW lpDisplayDevice, [in] DWORD dwFlags ); 1、 枚举适配器信息 依据该函数的官方 Remark 说明，不指定 lpDevice，并递增 iDevNum 做循环枚举操作，来取得显示适配器的信息。 void XDDM::PrintAdapter(std::vector&lt;DISPLAY_DEVICE&gt;&amp; devices) { devices.clear(); int index = 0; while (true) { DISPLAY_DEVICE dev{}; dev.cb = sizeof(DISPLAY_DEVICE); if (EnumDisplayDevices(nullptr, index, &amp;dev, 0)) //使用nullptr取得显示卡适配器信息，也可用适配器名称进而取得显示器信息 { if (!(dev.StateFlags &amp; DISPLAY_DEVICE_MIRRORING_DRIVER)) { devices.push_back(dev); bool active = dev.StateFlags &amp; DISPLAY_DEVICE_ATTACHED_TO_DESKTOP; //当前接口是否启用了 //do something } ++index; WLOG(L&quot;ADAPTER==&gt; \\t devName:%s \\t devId:%s \\r\\n&quot;, dev.DeviceName, dev.DeviceID); } else break; } } 通过上述操作我们可以枚举到如下的显示适配器信息，所谓的显示适配器其实就是GPU显卡。在此我们需要理解一个概念即 &quot;同一适配器上可挂接多个监视器&quot;，换句话说就是当前系统上有多少个硬件接口，系统就会注册对应数量的显示器编号 \\\\.\\DISPLAY*。 ADAPTER==&gt; devName:\\\\.\\DISPLAY1 devId:PCI\\VEN_8086&amp;DEV_0412&amp;SUBSYS_85341043&amp;REV_06 ADAPTER==&gt; devName:\\\\.\\DISPLAY2 devId:PCI\\VEN_8086&amp;DEV_0412&amp;SUBSYS_85341043&amp;REV_06 ADAPTER==&gt; devName:\\\\.\\DISPLAY3 devId:PCI\\VEN_8086&amp;DEV_0412&amp;SUBSYS_85341043&amp;REV_06 从设备信息打印中可看到 devId 都相同，而不同的三个 devName 接口分别注册在系统注册表中，分别对应的是主板上的三个显示器插槽（DVI、HDMI、VGA）。该解释无从考证，但我们可以通过CPU规格书中的“显示器数量”和“图形输出”信息，以及主板的插槽设计佐证这一点。 2、 枚举监视器信息 枚举到适配器信息后，以适配器名称传参至 lpDevice，并递增 iDevNum 再次做循环枚举操作，来取得显示监视器的信息。 void XDDM::PrintMonitor(std::vector&lt;DISPLAY_DEVICE&gt;&amp; devices) { bool find = false; if (!devices.empty()) { for (auto dev = devices.begin(); dev != devices.end();) { int index = 0; while (true) { DISPLAY_DEVICE tempDev{}; tempDev.cb = sizeof(DISPLAY_DEVICE); if (EnumDisplayDevices(dev-&gt;DeviceName, index, &amp;tempDev, EDD_GET_DEVICE_INTERFACE_NAME)) { bool active = tempDev.StateFlags &amp; DISPLAY_DEVICE_ACTIVE; //do something ++index; WLOG(L&quot;MONITOR==&gt; \\t devName:%s \\t active:%d \\t attached:%d \\ndevId:%s \\r\\n\\n&quot; , tempDev.DeviceName , tempDev.StateFlags &amp; DISPLAY_DEVICE_ACTIVE , tempDev.StateFlags &amp; DISPLAY_DEVICE_ATTACHED , tempDev.DeviceID ); } else { ++dev; //goto next break; } } } } } 通过以上操作可取得如下的详细监视器信息，注意： MONITOR==&gt; devName:\\\\.\\DISPLAY1\\Monitor0 active:1 attached:2 devId:\\\\?\\DISPLAY#TCL0000#4&amp;35aefc14&amp;0&amp;UID50725632#{e6f07b5f-ee97-4a90-b076-33f57bf4eaa7} MONITOR==&gt; devName:\\\\.\\DISPLAY2\\Monitor0 active:1 attached:2 devId:\\\\?\\DISPLAY#HKC21A6#4&amp;35aefc14&amp;0&amp;UID16843008#{e6f07b5f-ee97-4a90-b076-33f57bf4eaa7} 从上方的监视器信息打印中可了解一个基础信息，监视器挂接在适配器端口下。上面这些基础打印信息有助于我们使用WDDM模型接口函数。 二、 WDDM WDDM是我们实现自定义的设置的主要接口模型，该接口模型下主要提供以下接口函数： DisplayConfigGetDeviceInfo DisplayConfigSetDeviceInfo GetDisplayConfigBufferSizes QueryDisplayConfig SetDisplayConfig 需要注意是的 GetDisplayConfigBufferSizes、QueryDisplayConfig、SetDisplayConfig 这几个函数要求程序是桌面程序，拥有访问控制台会话或桌面能力否者将其返回 ERROR_ACCESS_DENIED。 在WDDM模型中，微软简化了配置方式。抽象出了两个概念 PATH 和 MODE，后续的所有操作均围绕这两个概念展开。其中 MODE 相关的原型结构定义如下： typedef struct DISPLAYCONFIG_SOURCE_MODE { UINT32 width; UINT32 height; DISPLAYCONFIG_PIXELFORMAT pixelFormat; POINTL position; } DISPLAYCONFIG_SOURCE_MODE; typedef struct DISPLAYCONFIG_TARGET_MODE { DISPLAYCONFIG_VIDEO_SIGNAL_INFO targetVideoSignalInfo; } DISPLAYCONFIG_TARGET_MODE; typedef struct DISPLAYCONFIG_MODE_INFO { DISPLAYCONFIG_MODE_INFO_TYPE infoType; UINT32 id; LUID adapterId; union { DISPLAYCONFIG_TARGET_MODE targetMode; DISPLAYCONFIG_SOURCE_MODE sourceMode; }; } DISPLAYCONFIG_MODE_INFO; 而 PATH 相关的原型结构定义如下： typedef struct DISPLAYCONFIG_PATH_SOURCE_INFO { LUID adapterId; UINT32 id; UINT32 modeInfoIdx; UINT32 statusFlags; } DISPLAYCONFIG_PATH_SOURCE_INFO; typedef struct DISPLAYCONFIG_PATH_TARGET_INFO { LUID adapterId; UINT32 id; UINT32 modeInfoIdx; DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY outputTechnology; DISPLAYCONFIG_ROTATION rotation; DISPLAYCONFIG_SCALING scaling; DISPLAYCONFIG_RATIONAL refreshRate; DISPLAYCONFIG_SCANLINE_ORDERING scanLineOrdering; BOOL targetAvailable; UINT32 statusFlags; } DISPLAYCONFIG_PATH_TARGET_INFO; typedef struct DISPLAYCONFIG_PATH_INFO { DISPLAYCONFIG_PATH_SOURCE_INFO sourceInfo; DISPLAYCONFIG_PATH_TARGET_INFO targetInfo; UINT32 flags; } DISPLAYCONFIG_PATH_INFO; 从定义中有些难以理解这两者之间关系，我们通过一些操作将其打印出实际数据，更方便观察其两者之间的相互关系。 1、 如何设置显示模式 要想设置显示模式则其主要操作是构建一个 PATH 与 MODE 的匹配对列。并最终交由函数 SetDisplayConfig 执行设置操作。要实现这一过程则先需要弄清楚这两者之前的匹配关系。 1.1 打印 PATH 与 MODE 的数据 首先我们定义一个辅助结构如下： typedef struct _DISPLAYCONFIG_SETTING_INFO { std::shared_ptr&lt;DISPLAYCONFIG_PATH_INFO&gt; pathPtr; size_t pathCount; std::shared_ptr&lt;DISPLAYCONFIG_MODE_INFO&gt; modePtr; size_t modeCount; } DISPLAYCONFIG_SETTING_INFO; 依据微软官方文档搭配 GetDisplayConfigBufferSizes 与 QueryDisplayConfig 这两接口函数取得当前系统内的显示设置。 bool WDDM::GetPathModeInfo(DISPLAYCONFIG_SETTING_INFO&amp; setInfo, bool queryAll) { //这几个函数 GetDisplayConfigBufferSizes / QueryDisplayConfig / SetDisplayConfig //要求程序是桌面程序，拥有访问控制台会话或桌面否者将其返回 ERROR_ACCESS_DENIED if (GetDisplayConfigBufferSizes(queryAll ? QDC_ALL_PATHS : QDC_ONLY_ACTIVE_PATHS, &amp;setInfo.pathCount, &amp;setInfo.modeCount) == ERROR_SUCCESS) { setInfo.pathPtr = std::shared_ptr&lt;DISPLAYCONFIG_PATH_INFO&gt;(new DISPLAYCONFIG_PATH_INFO[setInfo.pathCount]{}, std::default_delete&lt;DISPLAYCONFIG_PATH_INFO[]&gt;{}); setInfo.modePtr = std::shared_ptr&lt;DISPLAYCONFIG_MODE_INFO&gt;(new DISPLAYCONFIG_MODE_INFO[setInfo.modeCount]{}, std::default_delete&lt;DISPLAYCONFIG_MODE_INFO[]&gt;{}); return QueryDisplayConfig(queryAll ? QDC_ALL_PATHS : QDC_ONLY_ACTIVE_PATHS , &amp;setInfo.pathCount , setInfo.pathPtr.get() , &amp;setInfo.modeCount , setInfo.modePtr.get() , nullptr) == ERROR_SUCCESS; } return false; } 此时取得的 PATH 和 MODE 信息还比较简陋，还需要继续对其数据进行查询。为此我很还需要再定义一个带有扩展的数据的 DISPLAYCONFIG_PATH_INFO_EX如下： typedef struct _PATH_INFO_EX { DISPLAYCONFIG_SOURCE_MODE srcMode; //DISPLAYCONFIG_SOURCE_DEVICE_NAME wchar_t srcDevName[32]; //DISPLAYCONFIG_TARGET_PREFERRED_MODE unsigned int dstWidth; unsigned int dstHeight; DISPLAYCONFIG_TARGET_MODE dstMode; //DEVMODE devMode{}; //devMode.dmSize = sizeof(DEVMODE); //EnumDisplaySettingsEx(srcDevName, ENUM_REGISTRY_SETTINGS, &amp;devMode, EDS_RAWMODE)) DISPLAYCONFIG_PIXELFORMAT dstPixelFormat; //DISPLAYCONFIG_ADAPTER_NAME wchar_t srcAdapterPath[128]; wchar_t dstAdapterPath[128]; //DISPLAYCONFIG_TARGET_DEVICE_NAME wchar_t dstMonitorName[64]; wchar_t dstMonitorPath[128]; DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY dstOutputTechnology; } PATH_INFO_EX; typedef struct _DISPLAYCONFIG_PATH_INFO_EX { DISPLAYCONFIG_PATH_INFO path; PATH_INFO_EX ex; } DISPLAYCONFIG_PATH_INFO_EX; 基于 DisplayConfigGetDeviceInfo 接口函数，依据不同参数类型取得该 PATH 的其他可用信息并将其存储到一个新的PATH队列。其中在查询过程对其 PATH 的有效性做过滤，对于查询不到监视器的设备路径的 PATH 应当认定为没有物理连接从而对其丢弃。该操作实现如下： bool WDDM::FillInfoEx(DISPLAYCONFIG_SETTING_INFO &amp;setInfo, DISPLAYCONFIG_PATH_INFO_EX&amp; infoEx, bool &amp;isDefault) { LUID&amp; srcAdapterId = infoEx.path.sourceInfo.adapterId; LUID&amp; dstAdapterId = infoEx.path.targetInfo.adapterId; UINT&amp; srcId = infoEx.path.sourceInfo.id; UINT&amp; dstId = infoEx.path.targetInfo.id; DISPLAYCONFIG_TARGET_DEVICE_NAME targetName{}; targetName.header.size = sizeof(DISPLAYCONFIG_TARGET_DEVICE_NAME); targetName.header.type = DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_NAME; targetName.header.adapterId = dstAdapterId; targetName.header.id = dstId; if (DisplayConfigGetDeviceInfo(&amp;targetName.header) == ERROR_SUCCESS) { infoEx.ex.dstOutputTechnology = targetName.outputTechnology; wcscpy_s(infoEx.ex.dstMonitorPath, targetName.monitorDevicePath); wcscpy_s(infoEx.ex.dstMonitorName, targetName.monitorFriendlyDeviceName); isDefault = wcsstr(infoEx.ex.dstMonitorPath, L&quot;Default_Monitor&quot;) != nullptr; //不插显示器开机时系统的默认路径 bool hasName = wcslen(infoEx.ex.dstMonitorName); //系统默认监视器就没有名称 bool hasPath = wcslen(infoEx.ex.dstMonitorPath); //TODO: 系统会保留以往插过的显示器配置，但如果当前没有插入则不会有监视器的设备路径 //TODO: 在不插任何显示器是系统有默认的输出监视器，且没有名称，在变为默认监视器时好像还会保留最后一次配置正确的 dstOutputTechnology //所以不能单纯的用有没有名称来判断有效性，此处同时使用监视器设备路径来确定，只有有路径则说明设备在硬件层面上已连接 if (hasPath) { DISPLAYCONFIG_SOURCE_DEVICE_NAME deviceName{}; deviceName.header.size = sizeof(DISPLAYCONFIG_SOURCE_DEVICE_NAME); deviceName.header.type = DISPLAYCONFIG_DEVICE_INFO_GET_SOURCE_NAME; deviceName.header.adapterId = srcAdapterId; deviceName.header.id = srcId; if (DisplayConfigGetDeviceInfo(&amp;deviceName.header) == ERROR_SUCCESS) wcscpy_s(infoEx.ex.srcDevName, deviceName.viewGdiDeviceName); DISPLAYCONFIG_ADAPTER_NAME adapterName{}; adapterName.header.size = sizeof(DISPLAYCONFIG_ADAPTER_NAME); adapterName.header.type = DISPLAYCONFIG_DEVICE_INFO_GET_ADAPTER_NAME; adapterName.header.adapterId = srcAdapterId; if (DisplayConfigGetDeviceInfo(&amp;adapterName.header) == ERROR_SUCCESS) wcscpy_s(infoEx.ex.srcAdapterPath, adapterName.adapterDevicePath) == 0; adapterName.header.adapterId = dstAdapterId; if (DisplayConfigGetDeviceInfo(&amp;adapterName.header) == ERROR_SUCCESS) wcscpy_s(infoEx.ex.dstAdapterPath, adapterName.adapterDevicePath) == 0; DISPLAYCONFIG_TARGET_PREFERRED_MODE preferredMode{}; preferredMode.header.size = sizeof(DISPLAYCONFIG_TARGET_PREFERRED_MODE); preferredMode.header.type = DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_PREFERRED_MODE; preferredMode.header.adapterId = dstAdapterId; preferredMode.header.id = dstId; if (DisplayConfigGetDeviceInfo(&amp;preferredMode.header) == ERROR_SUCCESS) { infoEx.ex.dstWidth = preferredMode.width; infoEx.ex.dstHeight = preferredMode.height; infoEx.ex.dstMode = preferredMode.targetMode; } DEVMODE devMode{}; devMode.dmSize = sizeof(DEVMODE); if (EnumDisplaySettingsEx(infoEx.ex.srcDevName, ENUM_REGISTRY_SETTINGS, &amp;devMode, EDS_RAWMODE)) //直接从注册设置中取得像素位 infoEx.ex.dstPixelFormat = devMode.dmBitsPerPel == 8 ? DISPLAYCONFIG_PIXELFORMAT_8BPP : devMode.dmBitsPerPel == 16 ? DISPLAYCONFIG_PIXELFORMAT_16BPP : devMode.dmBitsPerPel == 24 ? DISPLAYCONFIG_PIXELFORMAT_24BPP : devMode.dmBitsPerPel == 32 ? DISPLAYCONFIG_PIXELFORMAT_32BPP : DISPLAYCONFIG_PIXELFORMAT_NONGDI; if (setInfo.modePtr &amp;&amp; setInfo.modeCount) for (int srcModeIdx = 0; srcModeIdx &lt; setInfo.modeCount; srcModeIdx++) { const DISPLAYCONFIG_MODE_INFO &amp;modeRef = setInfo.modePtr.get()[srcModeIdx]; if (modeRef.id == infoEx.path.sourceInfo.id) infoEx.ex.srcMode = setInfo.modePtr.get()[srcModeIdx].sourceMode; } return true; } } return false; } 当前期扩展信息获取可用以后，现在我们准备一下 Debug 环境，实现对有效扩展信息的打印，帮助后期分析。 #define LOG(fmt, ...) printf(fmt, ##__VA_ARGS__) #define WLOG(fmt, ...) wprintf(fmt, ##__VA_ARGS__) #define MODE_TYPE(type) \\ type == DISPLAYCONFIG_MODE_INFO_TYPE_SOURCE \\ ? L&quot;source&quot; \\ : type == DISPLAYCONFIG_MODE_INFO_TYPE_TARGET \\ ? L&quot;target&quot; \\ : L&quot;other&quot; #define MODE_POSITION_X(type, modeRef) \\ type == DISPLAYCONFIG_MODE_INFO_TYPE_SOURCE \\ ? modeRef.sourceMode.position.x \\ : -1 #define MODE_POSITION_Y(type, modeRef) \\ type == DISPLAYCONFIG_MODE_INFO_TYPE_SOURCE \\ ? modeRef.sourceMode.position.y \\ : -1 #define MODE_INFO_FMT L&quot;MODE==&gt; \\t idx:%d \\t id:0x%08x \\t adpId:0x%08x \\t type:%s \\t x:%4d y:%4d \\n&quot; #define SHOW_MODE_INFO(i, modeRef) WLOG(MODE_INFO_FMT \\ , i \\ , modeRef.id \\ , modeRef.adapterId.LowPart \\ , MODE_TYPE(modeRef.infoType) \\ , MODE_POSITION_X(modeRef.infoType, modeRef) \\ , MODE_POSITION_Y(modeRef.infoType, modeRef) \\ ) #define PATH_TECH(tech) \\ tech == DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HD15 \\ ? L&quot;VGA&quot; \\ : tech == DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SVIDEO \\ ? L&quot;SVIDEO&quot; \\ : tech == DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPOSITE_VIDEO \\ ? L&quot;COMPOSITE_VIDEO&quot; \\ : tech == DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPONENT_VIDEO \\ ? L&quot;COMPONENT_VIDEO&quot; \\ : tech == DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DVI \\ ? L&quot;DVI&quot; \\ : tech == DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HDMI \\ ? L&quot;HDMI&quot; \\ : tech == DISPLAYCONFIG_OUTPUT_TECHNOLOGY_LVDS \\ ? L&quot;LVDS&quot; \\ : tech == DISPLAYCONFIG_OUTPUT_TECHNOLOGY_D_JPN \\ ? L&quot;D_JPN&quot; \\ : tech == DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDI \\ ? L&quot;SDI&quot; \\ : tech == DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EXTERNAL \\ ? L&quot;DISPLAYPORT_EXTERNAL&quot; \\ : tech == DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EMBEDDED \\ ? L&quot;DISPLAYPORT_EMBEDDED&quot; \\ : tech == DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EXTERNAL \\ ? L&quot;UDI_EXTERNAL&quot; \\ : tech == DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EMBEDDED \\ ? L&quot;UDI_EMBEDDED&quot; \\ : tech == DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDTVDONGLE \\ ? L&quot;SDTVDONGLE&quot; \\ : tech == DISPLAYCONFIG_OUTPUT_TECHNOLOGY_MIRACAST \\ ? L&quot;MIRACAST&quot; \\ : tech == DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INTERNAL \\ ? L&quot;INTERNAL&quot; \\ : tech == DISPLAYCONFIG_OUTPUT_TECHNOLOGY_FORCE_UINT32 \\ ? L&quot;FORCE_UINT32&quot; \\ : tech == DISPLAYCONFIG_OUTPUT_TECHNOLOGY_OTHER \\ ? L&quot;OTHER&quot; \\ : L&quot;Error&quot; #define PATH_INFO_MFT L&quot;PATH==&gt; \\t idx:%d \\t active:%d \\t width:%d \\t height:%d \\n&quot; \\ L&quot;\\t\\t srcDevName:%s \\t moitName:%s \\t signal:%s \\n&quot; \\ L&quot;\\t\\t srcId:0x%08x \\t srcAdpId:0x%08x \\t srcModeIdx:%d \\n&quot; \\ L&quot;\\t\\t dstId:0x%08x \\t dstAdpId:0x%08x \\t dstModeIdx:%d \\n&quot; \\ L&quot;moitDevPath:%s \\r\\n\\n&quot; #define SHOW_PATH_INFO(i, infoEx) WLOG(PATH_INFO_MFT \\ , i \\ , infoEx.path.flags &amp; DISPLAYCONFIG_PATH_ACTIVE \\ , infoEx.ex.dstWidth \\ , infoEx.ex.dstHeight \\ , infoEx.ex.srcDevName \\ , infoEx.ex.dstMonitorName \\ , PATH_TECH(infoEx.path.targetInfo.outputTechnology) \\ , infoEx.path.sourceInfo.id \\ , infoEx.path.sourceInfo.adapterId.LowPart \\ , infoEx.path.sourceInfo.modeInfoIdx \\ , infoEx.path.targetInfo.id \\ , infoEx.path.targetInfo.adapterId.LowPart \\ , infoEx.path.targetInfo.modeInfoIdx \\ , infoEx.ex.dstMonitorPath \\ ) void WDDM::ShowSettingInfo(DISPLAYCONFIG_SETTING_INFO&amp; setInfo , std::vector&lt;DISPLAYCONFIG_PATH_INFO_EX&gt;&amp; infoExVec) { if (setInfo.modePtr &amp;&amp; setInfo.modeCount) for (size_t i = 0; i &lt; setInfo.modeCount; i++) { const DISPLAYCONFIG_MODE_INFO&amp; modeRef = setInfo.modePtr.get()[i]; SHOW_MODE_INFO(i, modeRef); } LOG(&quot;\\n&quot;); int validCount = infoExVec.size(); if (validCount &gt; 0) for (size_t i = 0; i &lt; validCount; i++) { const DISPLAYCONFIG_PATH_INFO_EX&amp; infoEx = infoExVec[i]; SHOW_PATH_INFO(i, infoEx); } } 此时扩展数据的获取和打印环境以准备完成，对此我们将这些扩展信息打印出来。 DISPLAYCONFIG_SETTING_INFO setInfo{}; if (WDDM::GetPathModeInfo(setInfo, true)) { std::vector&lt;DISPLAYCONFIG_PATH_INFO_EX&gt; infoExVec; if (setInfo.pathPtr &amp;&amp; setInfo.pathCount) for (int i = 0; i &lt; setInfo.pathCount; i++) { const DISPLAYCONFIG_PATH_INFO&amp; infoRef = setInfo.pathPtr.get()[i]; DISPLAYCONFIG_PATH_INFO_EX infoEx{ infoRef }; bool isDefault = false; if (WDDM::FillInfoEx(setInfo, infoEx, isDefault)) infoExVec.push_back(infoEx); } WDDM::ShowSettingInfo(setInfo, infoExVec); } 到此时我们可以得到如下的调试信息，将帮助我理解 PATH 和 MODE 的相互关系，需要注意的是在 FillInfoEx 阶段已经过滤了无效的项目。 MODE==&gt; idx:0 id:0x03060300 adpId:0x0000b808 type:target x: -1 y: -1 MODE==&gt; idx:1 id:0x00000000 adpId:0x0000b808 type:source x:1920 y: 0 MODE==&gt; idx:2 id:0x01010100 adpId:0x0000b808 type:target x: -1 y: -1 MODE==&gt; idx:3 id:0x00000001 adpId:0x0000b808 type:source x: 0 y: 0 PATH==&gt; idx:0 active:1 width:1920 height:1080 srcDevName:\\\\.\\DISPLAY1 moitName:3DTV signal:HDMI srcId:0x00000000 srcAdpId:0x0000b808 srcModeIdx:1 dstId:0x03060300 dstAdpId:0x0000b808 dstModeIdx:0 moitDevPath:\\\\?\\DISPLAY#TCL0000#4&amp;35aefc14&amp;0&amp;UID50725632#{e6f07b5f-ee97-4a90-b076-33f57bf4eaa7} PATH==&gt; idx:1 active:1 width:1920 height:1080 srcDevName:\\\\.\\DISPLAY2 moitName:H220 signal:VGA srcId:0x00000001 srcAdpId:0x0000b808 srcModeIdx:3 dstId:0x01010100 dstAdpId:0x0000b808 dstModeIdx:2 moitDevPath:\\\\?\\DISPLAY#HKC21A6#4&amp;35aefc14&amp;0&amp;UID16843008#{e6f07b5f-ee97-4a90-b076-33f57bf4eaa7} PATH==&gt; idx:2 active:0 width:1920 height:1080 srcDevName:\\\\.\\DISPLAY1 moitName:H220 signal:VGA srcId:0x00000000 srcAdpId:0x0000b808 srcModeIdx:1 dstId:0x01010100 dstAdpId:0x0000b808 dstModeIdx:2 moitDevPath:\\\\?\\DISPLAY#HKC21A6#4&amp;35aefc14&amp;0&amp;UID16843008#{e6f07b5f-ee97-4a90-b076-33f57bf4eaa7} PATH==&gt; idx:3 active:0 width:1920 height:1080 srcDevName:\\\\.\\DISPLAY3 moitName:H220 signal:VGA srcId:0x00000002 srcAdpId:0x0000b808 srcModeIdx:-1 dstId:0x01010100 dstAdpId:0x0000b808 dstModeIdx:2 moitDevPath:\\\\?\\DISPLAY#HKC21A6#4&amp;35aefc14&amp;0&amp;UID16843008#{e6f07b5f-ee97-4a90-b076-33f57bf4eaa7} PATH==&gt; idx:4 active:0 width:1920 height:1080 srcDevName:\\\\.\\DISPLAY2 moitName:3DTV signal:HDMI srcId:0x00000001 srcAdpId:0x0000b808 srcModeIdx:3 dstId:0x03060300 dstAdpId:0x0000b808 dstModeIdx:0 moitDevPath:\\\\?\\DISPLAY#TCL0000#4&amp;35aefc14&amp;0&amp;UID50725632#{e6f07b5f-ee97-4a90-b076-33f57bf4eaa7} PATH==&gt; idx:5 active:0 width:1920 height:1080 srcDevName:\\\\.\\DISPLAY3 moitName:3DTV signal:HDMI srcId:0x00000002 srcAdpId:0x0000b808 srcModeIdx:-1 dstId:0x03060300 dstAdpId:0x0000b808 dstModeIdx:0 moitDevPath:\\\\?\\DISPLAY#TCL0000#4&amp;35aefc14&amp;0&amp;UID50725632#{e6f07b5f-ee97-4a90-b076-33f57bf4eaa7} 基于以上的调试信息我们可以知道下面这些有用的规律信息： 在同一适配器（dstAdpId）上的不同监视器（moitDevPath）可被安排到不同编号（srcDevName）上。如果将过滤掉的数据全部打印出来，则会发现所有的 PATH 其实是对适配器、编号、监视器这三者的穷举排列。 在 PATH 的打印中 srcId、 srcModeIdx、dstId、 dstModeIdx 均对于与 MODE打印中的 id 和 idx，其中 idx （数组索引的简写）不存在时用 “-1” 代替。同时该条路径是否处于激活由 DISPLAYCONFIG_PATH_INFO 中的 flags 是否设置 DISPLAYCONFIG_PATH_ACTIVE 确定。在某些工控类主板中，可能出现打印的 signal 不是你实际硬件的类型，比如打印为 DISPLAYPORT_EXTERNAL 但实际硬件接口却是 VGA，出现这种情况一般是主板使用显示信号转换芯片。 在 MODE 的打印中 target 在前 source 在后。 到此时基本关系已经明确，将一个监视器 moitDevPath 绑定在编号 srcDevName 上。设置需要的分辨率到 srcMode 并将其连接到 dstMode，由此构建一条完整的 PATH ，两者之间的关系可做下图说明： flowchart LR subgraph MODE array dstMode1[idx:0 target mode1] srcMode1[idx:1 source mode1] dstMode2[idx:2 target mode2] srcMode2[idx:3 source mode2] end subgraph PATH array path1[idx:0 path1] path2[idx:1 path2] end dstMode1 -->|dstModeIdx| path1 srcMode1 -->|srcModeIdx| path1 dstMode2 -->|dstModeIdx| path2 srcMode2 -->|srcModeIdx| path2 为此要自定义显示模式则只需要构建一个满足上方规则的 MODE 数组和 PATH 数组。将其传递给传递给 SetDisplayConfig 执行设置，不要忘了给 PATH 的 flags 设定 DISPLAYCONFIG_PATH_ACTIVE 激活，该接口函数如果需要立即生效则需要注意使用以下参数搭配： bool SetSettingInfo(const DISPLAYCONFIG_SETTING_INFO &amp;setInfo) { // SetDisplayConfig 要求程序是桌面程序，拥有访问控制台会话或桌面否者将其返回 ERROR_ACCESS_DENIED return SetDisplayConfig(setInfo.pathCount , setInfo.pathPtr.get() , setInfo.modeCount , setInfo.modePtr.get() , SDC_USE_SUPPLIED_DISPLAY_CONFIG | SDC_APPLY | SDC_SAVE_TO_DATABASE | SDC_ALLOW_CHANGES | SDC_FORCE_MODE_ENUMERATION ) == ERROR_SUCCESS; } 2、 如何定制显示模式 定制显示模式主要在于对 DISPLAYCONFIG_MODE_INFO中的sourceMode的合理设置。 2.1 单主屏幕显示 实现单主屏显示效果，则我们值需要构建一条 PATH 即可。由于单屏显示不需要设置如扩展或者复制模式，则我应该将其 PATH 对应的DISPLAYCONFIG_MODE_INFO中的 sourceMode 下的 position 重置为“0,0”。 2.2 双屏显示如何设置 在多屏幕模式下主要有复制和扩展这两种模式，这两种模式设置方法一样，单使用的配置参数不一致，两种模式都有自己的强制要求。 2.2.1 复制模式 要构建一个复制模式则可先分析复制模式的显示特点，两个屏幕会显示一样的分辨率、显示位置。在一个外接两块屏幕的系统中设置复制模式，则在构建这两条 PATH 时，每一条 PATH 对应的DISPLAYCONFIG_MODE_INFO中的 sourceMode 下的 position 一定要都为“0,0”。其主要伪代码操作如下： srcModeInfo1.sourceMode.width = 1366; srcModeInfo1.sourceMode.height = 768; srcModeInfo1.sourceMode.position.x = 0; srcModeInfo1.sourceMode.position.y = 0; ... srcModeInfo2.sourceMode.width = 1366; srcModeInfo2.sourceMode.height = 768; srcModeInfo2.sourceMode.position.x = 0; srcModeInfo2.sourceMode.position.y = 0; 2.2.1 扩展模式 扩展模式相对自由度更高，每个显示器可以自定义的自己的分辨率和显示位置。但扩展模式有一个硬性要求就是两条路径形成的矩形的之间不能有缝隙，两个矩形至少有一个共同的边，否则将会设置无效。该规则基于Window系统分辨以屏幕左上角为原点，以主屏幕左上角 0,0 为参考。 flowchart LR L[-1366,0] --- M[0,0] --- R[1920,0] 基于横向的排列规则，将屏幕2放置在主屏幕左側则可以有如下伪代码： srcModeInfo1.sourceMode.width = 1920; srcModeInfo1.sourceMode.height = 1080; srcModeInfo1.sourceMode.position.x = 0; srcModeInfo1.sourceMode.position.y = 0; ... srcModeInfo2.sourceMode.width = 1366; srcModeInfo2.sourceMode.height = 768; srcModeInfo2.sourceMode.position.x = -1366; srcModeInfo2.sourceMode.position.y = 0; flowchart TB A[0,-768] --- C[0,0] --- B[0,1080] 基于竖向的排列规则，将屏幕2放置在主屏幕上側则可以有如下伪代码： srcModeInfo1.sourceMode.width = 1920; srcModeInfo1.sourceMode.height = 1080; srcModeInfo1.sourceMode.position.x = 0; srcModeInfo1.sourceMode.position.y = 0; ... srcModeInfo2.sourceMode.width = 1366; srcModeInfo2.sourceMode.height = 768; srcModeInfo2.sourceMode.position.x = 0; srcModeInfo2.sourceMode.position.y = -768; 有一个特例是斜角45°排列，则两矩形的两个顶点相靠，将屏幕2放置在主屏幕左上斜角45°位置则可以有如下伪代码： srcModeInfo1.sourceMode.width = 1920; srcModeInfo1.sourceMode.height = 1080; srcModeInfo1.sourceMode.position.x = 0; srcModeInfo1.sourceMode.position.y = 0; ... srcModeInfo2.sourceMode.width = 1366; srcModeInfo2.sourceMode.height = 768; srcModeInfo2.sourceMode.position.x = -1366; srcModeInfo2.sourceMode.position.y = -768; ","link":"https://yjulm.com/post/custom-display-mode/"},{"title":"职业生涯之技术总结大纲","content":"一、 软件 1、 缓冲 环行缓冲的设计和实现 环行缓冲的扩展应用之 - 滑动窗口 大对象OOM之不连续的内存碎片的利用 - 非托管内存流 大对象OOM之超大分辨率图像的像素解压 2、 设计 基于内存映射与信号量的本机大块数据交换与通信 多线程任务调度器的设计与实现 利用处理器空闲时间的异步和双线程操作设计 3、 图像 索引灰度图的调色板 图像处理中的通用概念之 - Stride BMP文件头与DIB 纯色背景图的快速剪裁原理和实践 Brush、ImageSource、Visual 三者之间的互相转化与 UIElement 的离屏渲染 4、 音频 PortAudio 的使用方式和范例 5、 视频 FFMPEG视频封装之MP4压制 SDL2的使用方式和范例 6、 网络 NAT在网络通信中的影响与穿透 基于滑动窗口设计的可靠UDP通信协议 二、 硬件 1、 TOUCH WPF程序在触摸失效时的解决方案 2、 MONITOR 自定义显示器的显示模式原理和实现 显示器与触摸屏的一对一绑定原理和解析 3、 IIC /SMBus /PCH SMBus 和 IIC 协议的基本认识 南桥芯片PCH的SMBus操作原理和GPIO操控范例 4、 LPCIO / EC 基于环境控制芯片EC的GPIO操控原理 5、 SMBIOS / DMTF 主板软硬件中的DMTF信息获取 6、 PCI /PCH 枚举PCI设备的原理 PCI设备基址的获取原理和范例 三、 其他 将最小化和隐藏以及后台的窗口带到前台 2021-11-15 拟稿 ","link":"https://yjulm.com/post/tech-doc-overview/"},{"title":"将最小化、隐藏、后台的窗口带到前台","content":" 当我们在实际办公场景中，经常会出现打开一个文档后由于处理其他事情而最小化了文档窗口，或者当前窗口被其他窗口遮挡后一段时间，从而忘记了已经打开过原文档。此时重新打开这个文档，那么如何做到不创建新窗口而直接激活原来的文档窗口，这就是当前探讨的问题。 一、 取得窗口句柄 激活窗口的关键在于如何找到这个窗口，在Win系统中有提供如下可用的窗口函数。 EnumDesktopWindows GetWindowText 首先我们通过 EnumDesktopWindows 枚举所有的桌面顶级窗口，该函数接受一个 WNDENUMPROC 函数指针，将枚举过程将委托给函数指针执行。该函数原型如下： delegate bool WNDENUMPROC(IntPtr hWnd, IntPtr lParam); 该原型中 hWnd 为枚举到窗口句柄， lParam 为承接 EnumDeskWindows 所传入的自定义数据。 要激活一个已经打开文档窗口，我们可以在窗口枚举过程中使用文档名称匹配窗口名称来 定位实际的文档窗口。EnumDesktopWindows 函数的原型如下： bool EnumDesktopWindows([In()] IntPtr hDesktop, WNDENUMPROC lpfn, [In] IntPtr lParam); 该枚举函数不直接返回枚举结果，基于 lParam 的指针参数类型，我们需要实现一个结构来承载数据的输入和输出： IntPtr[] args = new[] { Marshal.StringToHGlobalAnsi(name), Marshal.AllocHGlobal(IntPtr.Size), }; 我们以 name 作为窗口匹配名称并分配到非托管内存，紧接着在非托管内存再分配一个可容纳指针的内存块存储返回数据，我们将两块内存的指针构建一个新的指针数组并将其传递到 EnumDesktopWinddows 中来启动枚举操作。 GCHandle handle = GCHandle.Alloc(args, GCHandleType.Pinned); IntPtr argsPtr = handle.AddrOfPinnedObject(); EnumDesktopWindows(IntPtr.Zero, _enumProc, argsPtr); 为防止 GC 移动对象扰乱 PInvoke 的交互操作，需要将此指针数组固定在内存中。枚举工作正式启动，下面调用栈来到 WNDENUMPROC 的枚举回调中： IntPtr namePtr = Marshal.ReadIntPtr(lParam); IntPtr writePtr = Marshal.ReadIntPtr(IntPtr.Add(lParam, IntPtr.Size)); //数组的第二个元素 string findName = Marshal.PtrToStringAnsi(namePtr); 在枚举过程中通过传入数据的 lParam 分别在 GC 固定对象的内存处，取得我们需要的窗口匹配名称字符串指针以及匹配完成的输出内存指针。 string wndTitle = new string(new char[MAX_PATH]); GetWindowText(hWnd, wndTitle, MAX_PATH - 1); if (wndTitle.Contains(findName)) Marshal.WriteIntPtr(writePtr, hWnd); 基于 GetWindowText 取得当前枚举窗口的窗口名称，并与 wndTitle 对比即可找到对应的窗口。将找到的窗口指针写回到GC固定内存的第二个位置，就完成了数据回传，通过直接使用指针数组的第二元素即可访问该回传窗口指针。 二、 激活窗口到前台 激活一个窗口到前台，可能遇到的情况有这么几种。 窗口处于Normal，但处于非激活的后台窗口 窗口已被Minimize，此时激活窗口必须先还原状态 窗口已被Hide，此时激活窗口必须先对窗口完成Show 实现以上这些操作则需要用到如下接口函数： GetWindowThreadProcessId GetCurrentThreadId AttachThreadInput IsIconic ShowWindow SetActiveWindow SetWindowPos SetForegroundWindow SetFocus 要完成以上的这些操作，有一个前提是完成这些操作的线程必须是创建窗口的线程。显然该文档窗口由打开文档的程序自己线程创建，无法达到这一要求。基于此的原因是Windows系统设计中，每一个 Thread 有自己的 MessageQueue。这也是无论基于MFC、WinForms、WPF设计的窗体程序，这些窗体都有自己的一个 WndProc 消息循环函数。要在一个线程中操作另一个线程创建的窗口，此时就需要借助 AttachThreadInput 来连接两个线程的消息队列。 uint procId = Win32.GetWindowThreadProcessId(hWnd, IntPtr.Zero); uint thrId = Win32.GetCurrentThreadId(); AttachThreadInput(procId, thrId, true); 我们首先借助 GetWindowThreadProcessId 通过窗口句柄 hWnd 来取得窗口的线程，然后使用 GetCurrentThreadId 取得当前线程，使用两个线程ID完成最后连接。 if (IsIconic(hWnd) ShowWindow(hWnd, SW_RESTORE); else ShowWindow(hWnd, SW_SHOW)); 完成连接后，使用 IsIconic 检测窗口的显示状态是否已最小化，如果是的话则对其还原显示状态，否则强制完成 Show，用作处理窗口被 Hide 的情况。 SetActiveWindow(hWnd); SetWindowPos(hWnd, HWND_TOPMOS, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW); SetWindowPos(hWnd, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW); SetForegroundWindow(hWnd); SetFocus(hWnd); AttachThreadInput(procId, thrId, false); 使用 SetActiveWindow 将其窗口激活，再通过 SetWindowPos 交错使用参数 HWND_TOPMOS 和 HWND_NOTOPMOST 将窗口置顶后还原，来将其窗口带到其他窗口的上层显示。 借助 SetForegroundWindow 设置窗口为前台窗口，并使用 SetFocus 给予窗口键盘焦点。最后分离两个线程完成整个操作。 ","link":"https://yjulm.com/post/activate-minimized-hidden-background-windows/"}]}